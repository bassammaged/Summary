# ---------------------------- start android architecture ---------------------------- #
    # ----- Recommendation:
        - Read summary of android_summary/01-introudction
        - Read summary of android_summary/02-create-project
        
    # ----- What is android?
        - Android is an operating system based on linux operating system, which means it using the technologies and methods of linux, for example:
            - file premissions.
            - file system.
            - navigiation.
            - users & groups.
            - etc...

        - Android OS is an open-source, can be found: https://source.android.com/ and provides in-depth details about android environment.

    # ----- android OS architecture:
        - You can check image clarify android architecture '/#00-images/android-architecture01.jpg' '/#00-images/android-architecture02.jpeg' 
                './#00-images/android-architecture03.png'
                    
        - Android architecture divided into 4 main layers:
            - Layer 1: Application
                It is the top-most layer of Android architecture. This layer consists of native Android applications and third-party installed apps. 
                They are bundled in an Android package and all the applications that are to be installed are written in this layer only such as contacts, 
                games, settings, and messages.

            - Layer 2: Application Framework 
                - System Services
                    System services are modular, focused components such as Window Manager, Search Service, or Notification Manager. 
                    Functionality exposed by application framework APIs communicates with system services to access the underlying hardware. 
                    Android includes two groups of services: system (such as Window Manager and Notification Manager) and media (services involved 
                    in playing and recording media).
                - Hardware Abstraction layer (HAL)
                    that allows the Android Application framework to communicate with hardware-specific device drivers. 
                    It acts as an interface for hardware vendors to implement. An android application uses HAL APIs to get commands from 
                    different hardware devices.

            - Layer 3: Middleware layer
                middleware divided into 2 main categories libraries and android runtime
                - libraries
                    This layer consists of a set of Libraries and Android Runtime. The Android component is built using native codes and require native libraries, 
                    which are written in C/C++ and most of the libraries are open source libraries. Also, this layer handles data that is 
                    specific to the hardware. Some of the native libraries are SSL, SQLite, Libc, OpenGL, media framework, FreeType and Surface Manager.
                - android runtime
                    It comprises of DVM (Dalvik Virtual Machine). Just like JAVA uses JVM, Android uses DVM to optimize battery life, memory and performance. 
                    The byte code generated by the Java compiler has to be converted to .dex file by DVM, as it has its own byte code. Also, 
                    multiple class files are created as one .dex file and the compressed .jar file is greater than the uncompressed .dex file.
                    
                    Has 2 components:
                        - DVM (Dalvik VM)
                            - Dex Files.
                            - Compact and efficient than class files.
                            - limited memory and battery powers.
                        - Core Libraries
                            - java 5std. edition
                            - collections, I/O, etc.

            - Layer 4: Linux Kernel
                Linux kernel is the bottom-most and important layer of the Android architecture and it is the core part of Android architecture.
                It provides features such as:
                    - Security
                    - Process management
                    - Memory management
                    - Device management
                    - Multitasking
                It is also responsible for a level of abstraction between device hardware and upper layers of Android architecture. It consists 
                of device drivers like camera, flash memory, Display, keypad, Wifi etc.

                Developing your device drivers is similar to developing a typical Linux device driver. Android uses a 
                version of the Linux kernel with a few special additions such as Low Memory Killer (a memory management 
                system that is more aggressive in preserving memory), wake locks the Binder IPC driver, and other features important for a 
                mobile embedded platform. These additions are primarily for system functionality and do not affect driver development. You 
                can use any version of the kernel as long as it supports the required features (such as the binder driver).
                
# ----------------------------   end android architecture ---------------------------- # 

# ---------------------------- start android virtual machines ---------------------------- #
    # ----- What is virtual machine:
        - A virtual machine is based on computer architectures to provide functionality of a computer. There are 2 main types of Virtual Machine (VM):
            1. System virtual machines: (full virtualization VMs) provide a substitute for a real machine.
            2. Process virtual machines: are designed to execute computer programs in a platform-independent environment.
        
        - architecture of system virtual machine: '../#00-images/virtual-machine-arch.png'

    # ----- Java virtual machine:
        - Java Virtual Machine (JVM) is a Process virtual machine. Follow “write once, run anywhere” principle, JVM allow programs — written in Java/Kotlin 
        to run on any device or operating system. As the figure: './#00-images/jvm-run-anywhere.png', './#00-images/jvm-everywhere.jpeg'
        
        # ----- How it works:
            - IDEs — like IntelliJ / Android Studio — use Java Compiler (javac) to compile Java code (.java) into Java bytecode (.class).
            - you can check the figure: './#00-images/jre-works.png' 
                1. Start JVM.
                2. Start main thread. Load .class into memory using Classloader.
                3. Verify bytecode is valid and not violate Java’s security restrictions.
                4. Translate bytecode into machine instructions and execute them.
                5. Unload classes. Terminate main thread.
                6. Shutdown JVM.

        # ----- JVM architecture:
            You can check JVM arch. here: "./#00-images/jvm-arch.png"
        
        # ----- Byte Code To Machine Code:
            - Byte code is get converted to machine level code using a dictionary of instructions (byte to m/c), because of different types of 
            machines(like Ubuntu, mac, windows, etc) have different types of the instruction set.
            - The interpreter is very quick to start and load the app.
            

    # ----- What is Android virtual machines:
        - virtual machines are abstraction layers between an application and the underlying android device. Android apps are written in java, but it 
        compiled into platfom independent Dalvik Executable (DEX, bytecode).
        
        - Layers are:
            1. Android App. (Java)
            2. Dex bytecode.
            3. Dalvik/ART VM.
            3. Android operating system.
        
        - Android virtual machine runs the DEX bytecode directly complied from the original Java. with no give a matter for OS type or hardware specification.

        - KitKat android version runs android virtual machine based on Dalvik VM while Lollipop android version was depending on new technology called android runtime (ART),
        which means Android phased out the dalvik VM entirely with Lollipop version.
        the both of them (DVM,ART) work on DEX bytecode but ART has new optimization features.

    # ----- Compiled apps:
        - usually google play store apps compiled into DEX bytecode or ODEX bytecode, ODEX bytecode used by OEMs to optimize apps that run at boot-time.
        - OAT files used with the newer android runtime (ART) and offers signifcant performance enahcements.


    # ----- Dalvik virtual machine:
        # ----- What is it?
            - Dalvik Virtual Machine (DVM) is a Process virtual machine for Android.
            - DVM is a virtual machine that optimized for mobile environment (memory, battery life, performance,..)
        
        # ----- Dalvik how it works?
            - Dalvik executes a .dex file, which in turn handles the interaction with the native code. as the following: './#00-images/dalvik-nativecode.jpg'
            - JVM and Dalvik flow: './#00-images/jvm-dalvik-flow.png' and './#00-images/dalvik-flow.jpg'
            - Multiple classes are included in a single .dex file.
            

        # ----- Dalvik EXecutable:
            - Dalvik EXecutable (DEX) is Dalvik bytecode which translated from Java bytecode (.class) using dx tool (replaced by D8 tool since API 28). 
            The DEX format was designed for systems that have constrained memory and processor speed.

        
    # ----- Android runtime:
        - Android Runtime (ART) is the managed runtime used by apps and system services on Android. Replacing the predecessor Dalvik, ART performs the translation of 
        the app’s bytecode into native instructions that are later executed by the device’s runtime environment.
        - From Android 5.0 (API 21), each app runs in its own process, with its own instance of ART. But prior to this, it use Dalvik. If your app runs 
        well on ART, then it should work on Dalvik as well, but the reverse may not true.
        
    # ----- Just-In-Time vs Ahead-Of-Time:
        # ----- Just-In-Time:
            - Bytecode to machine language through interpreting has one problem is interpreter does not perform any kind of optimization, because of that same byte code 
            get converted to machine code every time. To solve this problem C1 Compiler is used, which uses code cache.

            # ----- What is C1 Compiler?
                - So when interpreter interprets the byte code it uses counter how many times the same byte code gets converted to machine code which is 
                saved in the code cache.

        # ----- Ahead-Of-Time:
            - While doing profiling manually or manually check thread or memory dump from JVM we might need to perform compilation ahead of time. this feature is 
            enabled after JAVA9. After Java9 we have the option to convert some of the classes or libraries to compiled code before the start of the application.

        --> Note: read more about JIT and AOT: https://sauravomar01.medium.com/ahead-of-time-vs-just-in-time-in-java-8456f5a77e00
    # ----- Apps:
        - Android apps are constructed primarily using the Java programming language, it is possible for the direct use of native code as well, its commonly used for 
        high performance applications such as games.
        - The ART is written to run multiple VMs on low-memory devices. To maintain backward compatibility, ART also uses the same input bytecode as Dalvik, 
        the standard Dalvik EXecutable (.dex) files — which also designed for Android to minimize memory footprint.
# ----------------------------   end android virtual machines ---------------------------- #

# ---------------------------- start android security ---------------------------- #
    # ----- Intro:
        - One of the benefit from not using native code, via the android NDK, is that android applications written for the VMs do not suffer from the same
        types of memory corruption issues such as buffer overflows.

        - There are 2 layers of security:
            1. first layer: is implemented in the operating system and keeps installed application fundamentally isolated from one another.
            2. second layer: is the security layer in the application itself which:
                1. allows the application developers to selectively expose certian application functionalities to other applications.
                2. configures application capabilities in-line with their risk tolerance and use cases.

        # ----- First layer (implemented in OS):
            - this layer works on isolate th application from each other, this allows for a separation of data and code execution. This way different applications
            with different trust levels, from different developers all existing on the same device. for Example: you have 2 applications on your phone one of them 
            banking app. and another app. is pubg game, it doesn't mean pubg app. is able to access the banking account information that on banking app.

            - the isolation that implemented by the OS could take place due to:
                1. UID sepration:
                    - each app has its own user ID (UID) which is inherited from the underlying linux operating system. This assignment is done dynamically on installation.
                    - the application could interact with files that owned by its user ID, but no others, unless the y are shared with it by another application
                    or the OS itself.

                2. Sandboxing:
                    - Android depends on create a separation of files and code execution between applications on the same device. android sandboxing is implemented in
                    OS itself rather than the VM. which allows for the VM to interact with native code in the same application without constraints.
                    this sandboxing could be accomplished beacuse each application runs as a separate process under a separate user ID.

                    - SElinux adds more security implementation becuase it denies all process interactions and then creates policies to allow only the expected or 
                    "known good" interactions between them.
# ----------------------------   end android security ---------------------------- #


https://laptrinhx.com/virtual-machine-in-android-everything-you-need-to-know-586969274/ 